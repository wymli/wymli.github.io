<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Temporal on UnderTheHood</title>
    <link>https://wymli.github.io/tags/temporal/</link>
    <description>Recent content in Temporal on UnderTheHood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>CC BY 4.0 CN</copyright>
    <lastBuildDate>Thu, 08 May 2025 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://wymli.github.io/tags/temporal/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>TodoList</title>
      <link>https://wymli.github.io/2021/04/a2todo-todo-list/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/04/a2todo-todo-list/</guid>
      <description>&lt;h1 id=&#34;todolist&#34;&gt;TodoList&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;sysmon线程&lt;/li&gt;
&lt;li&gt;eBPF和ipvs : &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU1MzY4NzQ1OA==&amp;amp;mid=2247494326&amp;amp;idx=1&amp;amp;sn=82db83a0c03f45d1258f9563b5e465e7&amp;amp;chksm=fbedaa7bcc9a236df2dfae59f4f0400e6f3d15d747eaf66248a8bc9e3dda260a7cf203c6404e&amp;amp;xtrack=1&amp;amp;scene=90&amp;amp;subscene=93&amp;amp;sessionid=1617852418&amp;amp;clicktime=1617852482&amp;amp;enterid=1617852482&amp;amp;ascene=56&amp;amp;devicetype=android-29&amp;amp;version=2800023b&amp;amp;nettype=WIFI&amp;amp;abtest_cookie=AAACAA%3D%3D&amp;amp;lang=zh_CN&amp;amp;exportkey=A%2BaD1VoeZK%2BNcCdBAeTSRpU%3D&amp;amp;pass_ticket=ruwUaHgmNx%2FW6lI59EtPJWAVZNtV2JsX1zGoRFgjLCnzopLmGt361yB46zNl%2BcPs&amp;amp;wx_header=1&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;kafka client, 看看sarama,了解kafka客户端能获得哪些东西,server api暴露了哪些东西&lt;/li&gt;
&lt;li&gt;kv db, 比如etcd的boltdb多读少写, lsm-tree的多写少读&lt;/li&gt;
&lt;li&gt;etcd ,consul 的分布式共识&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[UnderTheHood] 基础-重要-知识-教旨-格言-蝉</title>
      <link>https://wymli.github.io/2021/04/a1underthehood-underthehood/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/04/a1underthehood-underthehood/</guid>
      <description>&lt;h1 id=&#34;underthehood&#34;&gt;UnderTheHood&lt;/h1&gt;
&lt;p&gt;这里记录一些具有重要的知识&lt;/p&gt;
&lt;h2 id=&#34;page-cache&#34;&gt;Page Cache&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;主存充当两个功能,一个是进程的存储空间(堆栈),一个磁盘的缓存(page cache)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如此一来,一切都说得通了,我们常说read要从内核缓冲区拷贝到用户缓冲区,你也许和我有一样的疑惑,为什么要先拷贝到内核缓冲区呢?不能直接拷贝到用户缓冲区呢?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[AI Agent] Eino</title>
      <link>https://wymli.github.io/2025/05/aiagent-eino/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/05/aiagent-eino/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文我记录在飞书文档: &lt;a href=&#34;https://c6t4wbgxht.feishu.cn/docx/WLmndFiDgokHVvxoBkZczB67n3b&#34;&gt;https://c6t4wbgxht.feishu.cn/docx/WLmndFiDgokHVvxoBkZczB67n3b&lt;/a&gt;
拷贝时会有格式问题&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Eino 是字节开源的golang写的 ai agent 开发框架，类似python写的langchain、llamaindex。
Ai agent 智能体，可以理解为是一种完成 “感知、思考、执行” 的程序，其中思考的部分借助大模型完成
大模型有三种主要的应用模式：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[DB] 事务隔离与锁</title>
      <link>https://wymli.github.io/2025/05/db-mutex/</link>
      <pubDate>Wed, 14 May 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/05/db-mutex/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文我记录在飞书文档: &lt;a href=&#34;https://c6t4wbgxht.feishu.cn/docx/Uyvadiw7zorRhLxww1LcMRaanib&#34;&gt;https://c6t4wbgxht.feishu.cn/docx/Uyvadiw7zorRhLxww1LcMRaanib&lt;/a&gt;
拷贝时会有格式问题&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;NOTE: 下文中区间锁（gap/next-key）锁住的区间有误，和我实际实验的区间对不上，但是网络上也没看到比较准确的答案，先待定。互联网业务一般不开rr，所以无影响。
四种隔离级别&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go] GMP</title>
      <link>https://wymli.github.io/2025/05/go-gmp/</link>
      <pubDate>Sun, 11 May 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/05/go-gmp/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文记录在飞书文档: &lt;a href=&#34;https://c6t4wbgxht.feishu.cn/docx/O5M1dTRLxol7G0xScsucuYm6nSg&#34;&gt;https://c6t4wbgxht.feishu.cn/docx/O5M1dTRLxol7G0xScsucuYm6nSg&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;golang的一大特点就是用户态线程(协程)是一等公民（即由语言的关键字创建，而不是某个标准库），我们来看下用户态线程的一些关键细节。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Go] release notes</title>
      <link>https://wymli.github.io/2025/05/go-release-notes/</link>
      <pubDate>Sat, 10 May 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/05/go-release-notes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文我记录在飞书文档: &lt;a href=&#34;https://c6t4wbgxht.feishu.cn/docx/Nu9sd0FobokaxMxEddxc9VTXnIg&#34;&gt;https://c6t4wbgxht.feishu.cn/docx/Nu9sd0FobokaxMxEddxc9VTXnIg&lt;/a&gt;
拷贝时会有格式问题&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tip.golang.org/doc/devel/release&#34;&gt;https://tip.golang.org/doc/devel/release&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;118&#34;&gt;1.18&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;加入泛型&lt;/li&gt;
&lt;li&gt;新增包：golang.org/x/exp/constraints&lt;/li&gt;
&lt;li&gt;新增包：golang.org/x/exp/slices&lt;/li&gt;
&lt;li&gt;新增包：golang.org/x/exp/maps&lt;/li&gt;
&lt;li&gt;新增 fuzz test&lt;/li&gt;
&lt;li&gt;go get 不再拥有go install的能力&lt;/li&gt;
&lt;li&gt;go编译时注入额外的版本控制信息到binary中，可以在代码里获取，也可以直接从二进制获取&lt;/li&gt;
&lt;li&gt;现在可以直接通过go version -m ${bin} 看到对应的vcs（比如git）的一些信息，比如代码对应的最后一次commit的时间，编译用的go版本等&lt;/li&gt;
&lt;li&gt;也可以import debug/buildinfo 在代码中获取这些信息&lt;/li&gt;
&lt;li&gt;需要注意的是，build time这个东西还是只能通过-ldflags=&amp;quot;-X &amp;lsquo;main.buildTime=$(date)&amp;rsquo;&amp;quot; 在编译时注入&lt;/li&gt;
&lt;li&gt;支持Workspace mode，如果在当前目录或父目录有go.work file，或者通过GOWORK env指定了go.work文件地址, 用来支持多个main module（比如原来vscode只支持单个go.mod file）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;119&#34;&gt;1.19&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;内存模型：The Go memory model has been revised to align Go with the memory model used by C, C++, Java, JavaScript, Rust, and Swift.&lt;/li&gt;
&lt;li&gt;引入 debug.SetMemoryLimit , 设置后，当堆+非堆内存到达对应设置的soft memory后，强制gc一次&lt;/li&gt;
&lt;li&gt;atomic包增加原子类型，比如atomic.Bool, 在之前atomic只有原子操作，没提供类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;120&#34;&gt;1.20&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;没啥特别的&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;121&#34;&gt;1.21&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;引入 min and max&lt;/li&gt;
&lt;li&gt;引入 clear, 可以 clear map/slice, 需要注意的是，对map，是清空，len变0；对slice，是将元素清零，但是len不变&lt;/li&gt;
&lt;li&gt;新增 log/slog， 结构化日志&lt;/li&gt;
&lt;li&gt;slices/maps包增加通用泛型方法&lt;/li&gt;
&lt;li&gt;sync增加 sync.OnceFunc, OnceValue&amp;hellip;，不再只是sync.Once&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;122&#34;&gt;1.22&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;for训练的value每次迭代时都会创建新的&lt;/li&gt;
&lt;li&gt;支持 for range ${n}&lt;/li&gt;
&lt;li&gt;支持  range-over-function iterators 函数迭代器&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;123&#34;&gt;1.23&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;增加iter包, 了解下iter.Seq, 迭代器类型，迭代器可以被for range使用，也可以直接传入yield函数（其实感觉更像是handle函数）&lt;/li&gt;
&lt;li&gt;iter.Seq 就是一个函数的别名
type (
Seq[V any]     func(yield func(V) bool)
Seq2[K, V any] func(yield func(K, V) bool)
)&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;124&#34;&gt;1.24&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;增加很多基于iter的util方法&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>[airflow] temporal</title>
      <link>https://wymli.github.io/2025/05/workflow-2.-temporal/</link>
      <pubDate>Thu, 08 May 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/05/workflow-2.-temporal/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文记录在飞书文档: &lt;a href=&#34;https://c6t4wbgxht.feishu.cn/docx/MQmod4xkdoZ2TlxDbQncyQG9nbg&#34;&gt;https://c6t4wbgxht.feishu.cn/docx/MQmod4xkdoZ2TlxDbQncyQG9nbg&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;简单介绍&#34;&gt;简单介绍&lt;/h1&gt;
&lt;p&gt;学习一个新的东西首先在搜索引擎上搜下，了解下大概是什么东西。如果直接看官网文档的话，有些假大空的不说人话，容易懵。但深入的话，还是要看官方文档和源码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[airflow] airflow</title>
      <link>https://wymli.github.io/2025/03/worklfow-1.-airflow/</link>
      <pubDate>Thu, 20 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/worklfow-1.-airflow/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文记录在飞书文档：https://c6t4wbgxht.feishu.cn/docx/POUfdFT2YoXlbHxeUA2cntmanzc&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[container] 6.容器基础之runc源码</title>
      <link>https://wymli.github.io/2025/03/container-6.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Brunc%E6%BA%90%E7%A0%81/</link>
      <pubDate>Fri, 14 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/container-6.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Brunc%E6%BA%90%E7%A0%81/</guid>
      <description>&lt;p&gt;git clone &lt;a href=&#34;https://github.com/opencontainers/runc.git&#34;&gt;https://github.com/opencontainers/runc.git&lt;/a&gt;, 我们简单阅读下，代码不多&lt;/p&gt;
&lt;h1 id=&#34;入口&#34;&gt;入口&lt;/h1&gt;
&lt;p&gt;入口没啥好说的，先找main.go文件，可以看到runc这个库用了 github.com/urfave/cli 这个命令行库和 github.com/sirupsen/logrus 这个日志库，能在这种比较重要的工具里面使用，说明这两个库是很不错的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[container] 5.容器基础之oci dist</title>
      <link>https://wymli.github.io/2025/03/container-5.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boci-dist/</link>
      <pubDate>Sun, 09 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/container-5.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boci-dist/</guid>
      <description>&lt;p&gt;oci distribution spec 比较简单，就是定义了一些用于pull/push 的api&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个有趣的事实是，oci registry 不只是存储镜像，也可以用于存储helm chart。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;pull&#34;&gt;Pull&lt;/h1&gt;
&lt;h2 id=&#34;pull-manifest&#34;&gt;Pull manifest&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;GET /v2/&lt;!-- raw HTML omitted --&gt;/manifests/&lt;!-- raw HTML omitted --&gt;
&lt;ol&gt;
&lt;li&gt;name: 一般是${namespace/image_name}, 比如 library/nginx&lt;/li&gt;
&lt;li&gt;reference：一般是digest或者tag，比如latest、v1.2.3、sha256:abc123&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;拉取下来的是符合oci image spec的manifest文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;pull-blobs&#34;&gt;Pull blobs&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;GET /v2/&lt;!-- raw HTML omitted --&gt;/blobs/&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;push&#34;&gt;Push&lt;/h1&gt;
&lt;p&gt;值得注意的是，在push image时，是先push blobs，再push manifest，与pull相反&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[container] 4.容器基础之oci image</title>
      <link>https://wymli.github.io/2025/03/container-4.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boci-image/</link>
      <pubDate>Thu, 06 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/container-4.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boci-image/</guid>
      <description>&lt;p&gt;描述了一个镜像的打包目录和相关文件的schema&lt;/p&gt;
&lt;h1 id=&#34;目录结构&#34;&gt;目录结构&lt;/h1&gt;
&lt;p&gt;利用docker save拿到一个docke 镜像的tar包，解包后得到如下目录，这是一个兼容oci image spec的目录（但也只是兼容，不是严格相等，里面有一些oci image spec里未定义的文件）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[container] 3.容器基础之runc</title>
      <link>https://wymli.github.io/2025/03/container-3.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Brunc/</link>
      <pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/container-3.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Brunc/</guid>
      <description>&lt;p&gt;如果没有安装runc，先安装 (如果你安装了dockerd/containerd，一般不用再单独安装)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/opencontainers/runc/releases/download/v1.2.5/runc.amd64 -O runc &amp;amp;&amp;amp; chmod +x runc
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;制作-bundle&#34;&gt;制作 bundle&lt;/h1&gt;
&lt;p&gt;安装oci runtime spec, 我们先制作oci runtime bundle，也就是config.json 和 rootfs&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[http] 流式响应之text/event-stream</title>
      <link>https://wymli.github.io/2025/03/http-%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%E4%B9%8Btext.event-stream/</link>
      <pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/http-%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%E4%B9%8Btext.event-stream/</guid>
      <description>&lt;p&gt;WIP&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[container] 1.容器基础之overlayfs</title>
      <link>https://wymli.github.io/2025/03/container-1.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boverlayfs/</link>
      <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/container-1.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boverlayfs/</guid>
      <description>&lt;p&gt;overlayfs ，如其名，覆盖文件系统，类似那些 overlay network一样（在underlay network上包一层），在原生的fs上包一层。&lt;br&gt;
overlayfs 是linux内核提供的功能，相关文档见 &lt;a href=&#34;https://docs.kernel.org/filesystems/overlayfs.html&#34;&gt;https://docs.kernel.org/filesystems/overlayfs.html&lt;/a&gt;&lt;br&gt;
容器使用 overlayfs 作为容器的文件系统，比如镜像是按层构建的，每一层都是lowerdir, 并创建一个容器的upperdir, 最终得到用户看到的容器文件系统。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[container] 2.容器基础之oci runtime</title>
      <link>https://wymli.github.io/2025/03/container-2.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boci-runtime/</link>
      <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/container-2.%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B9%8Boci-runtime/</guid>
      <description>&lt;p&gt;oci(open container initiative, 开放容器倡议) 主要有三个大的spec, runtime（容器运行时）、image（镜像）、distribution（分发）&lt;/p&gt;
&lt;h1 id=&#34;oci-runtime-spec&#34;&gt;OCI Runtime Spec&lt;/h1&gt;
&lt;p&gt;包含三方面：配置和打包定义（也就是bundle和config.json的schema）、执行环境、容器生命周期及相关操作&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[install] wsl 和 containerd 环境准备踩坑</title>
      <link>https://wymli.github.io/2025/03/install-wsl-%E5%92%8C-containerd-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</link>
      <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2025/03/install-wsl-%E5%92%8C-containerd-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</guid>
      <description>&lt;p&gt;后面开始用家里的windows主机开发和学习，换了新环境，配置环境很折磨，wsl虽说很方便，但是遇到各种坑，解决起来很费脑&lt;/p&gt;
&lt;h1 id=&#34;wsl2-配置&#34;&gt;wsl2 配置&lt;/h1&gt;
&lt;p&gt;2025年wsl已经有了很多新的演进，在网络方便进步很多，原来wsl1如果要连接宿主机的代理，需要配宿主机的ip，但是宿主机的ip不固定，比较麻烦（不过也就是一个脚本的事，问题也不大）&lt;br&gt;
wsl2支持镜像网络模式，wsl和host可以共用网络地址了，也就是wsl里可以通过localhost访问host。&lt;br&gt;
配置如下，在windows的用户目录下创建 &lt;code&gt;.wslconfig&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[distribute] 单应用分布式架构</title>
      <link>https://wymli.github.io/2022/04/distribute-%E5%8D%95%E5%BA%94%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2022/04/distribute-%E5%8D%95%E5%BA%94%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;
&lt;p&gt;对大部分的业务系统来说，分布式往往体现在微服务上，即多个服务之间的分布式网络调用。&lt;/p&gt;
&lt;p&gt;但是在分布式计算、分布式训练等特定领域，是需要真正的借助分布式机器进行并行计算或训练的，这一类应用也有几个经典的架构，或者说启动方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[task-queue] lmstfy</title>
      <link>https://wymli.github.io/2022/04/task-queue-lmstfy/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2022/04/task-queue-lmstfy/</guid>
      <description>&lt;h1 id=&#34;lmstfy&#34;&gt;lmstfy&lt;/h1&gt;
&lt;p&gt;碰巧github给我推了这个&lt;a href=&#34;https://github.com/bitleak/lmstfy&#34;&gt;任务队列&lt;/a&gt;，抽空读了下源码。如果第一次接触这种延时任务队列，还是挺有意思的。&lt;/p&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;p&gt;lmstfy使用redis作为底层存储，使用redis的list的&lt;code&gt;lpush&lt;/code&gt;,&lt;code&gt;brpop&lt;/code&gt;完成任务的生产和消费，消费要阻塞的pop，避免轮询。lmstfy使用redis设计了多个模块，ready队列是其一，还有timer zset的延时队列用来处理延时的任务，以及死信队列处理消费失败的任务。&lt;br&gt;
假设称任务为task或job，下面统一称之为job。对于一个任务的提交（生产），它具有下面的生命周期：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[BigData] yarn client</title>
      <link>https://wymli.github.io/2022/04/big-data-yarn/</link>
      <pubDate>Sat, 16 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2022/04/big-data-yarn/</guid>
      <description>&lt;h1 id=&#34;yarn-client&#34;&gt;Yarn Client&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>[BigData] spark</title>
      <link>https://wymli.github.io/2022/04/big-data-spark/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2022/04/big-data-spark/</guid>
      <description>&lt;h1 id=&#34;spark&#34;&gt;Spark&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;并行计算框架&lt;/li&gt;
&lt;li&gt;支持流式或批式&lt;/li&gt;
&lt;li&gt;spark提交有一个单独的spark-commit.sh脚本&lt;/li&gt;
&lt;li&gt;批处理是spark core&lt;/li&gt;
&lt;li&gt;流处理是spark streaming，这里的流在实现上是会传入一个窗口大小和下一个窗口的位移，来产生RDD，一个RDD就是一个窗口的小批次数据，所以spark streaming只是在批式spark core上包装了一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;执行流程&#34;&gt;执行流程&lt;/h2&gt;
&lt;p&gt;一个spark 应用的流程是这样的：&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
